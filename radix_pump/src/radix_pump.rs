/* This blueprint can instatiate a component that has multiple scopes:
    - Instantiate pool components
    - Act as a proxy towards pools
    - Centralize fees collection
    - Owner, creators and integrators authentication
    - Ensure that flash loans are returned
    - Execute hooks
    - Emit events generated by the pools

  A RadixPump component talks to the Pool components he creates (RadixPumpPoolInterfaceScryptoStub
  scrypto-interface) and the hooks (HookInterfaceScryptoStub scrypto-interface)
*/

use std::ops::DerefMut;
use scrypto::prelude::*;
use crate::common::*;
use crate::pool::pool::*;
use crate::hook_helpers::*;

// Metadata for this component
static DAPP_NAME: &str = "RadixPump";

// Metadata for the coin creator badge
static CREATOR_BADGE_NAME: &str = "Coin creator badge";

// Metadata for the flash loan transient NFT
static TRANSIENT_NFT_NAME: &str = "Flash loan transient NFT";

// Minimum buy fee for Fair and Random launch
static MIN_LAUNCH_BUY_FEE: Decimal = dec!("0.1");

// Metadata for the integrator badge
static INTEGRATOR_BADGE_NAME: &str = "Integrator badge";

// Some common error messsages
static COIN_NOT_FOUND: &str = "Coin not found";
static UNKNOWN_HOOK: &str = "Unknown hook";
static UNEXPECTED_METADATA_TYPE: &str = "Unexpected metadata type";
static WRONG_BADGE: &str = "Wrong badge";
static SHOULD_NOT_HAPPEN: &str = "Should not happen";

// Flash loan transient NFT data
#[derive(Debug, ScryptoSbor, NonFungibleData)]
struct FlashLoanData {
    coin_resource_address: ResourceAddress,
    coin_amount: Decimal,
}

// Non fungible data for the integrators badge
#[derive(Debug, ScryptoSbor, NonFungibleData)]
struct IntegratorData {
    name: String,
    creation_date: Instant,
    #[mutable]
    active: bool,
}

// This event is emitted when a coin creator enables an hook for his pool (resource_address is Some), or when the componet owner enables an event globally (resource_address is None)
#[derive(ScryptoSbor, ScryptoEvent)]
struct HookEnabledEvent {
    resource_address: Option<ResourceAddress>,
    hook_name: String,
    hook_address: HookInterfaceScryptoStub,
    operations: Vec<String>,
}

// This event is emitted when an hook is disablen for a pool (resource_address is Some), or when the componet owner disables an event globally (resource_address is None)
#[derive(ScryptoSbor, ScryptoEvent)]
struct HookDisabledEvent {
    resource_address: Option<ResourceAddress>,
    hook_name: String,
    hook_address: HookInterfaceScryptoStub,
    operations: Vec<String>,
}

// Informations about a Pool component
#[derive(ScryptoSbor)]
struct PoolStruct {
    component_address: RadixPumpPoolInterfaceScryptoStub,
    enabled_hooks: HooksPerOperation,
    creator_id: u64,
}

#[blueprint]
#[events(
    FairLaunchStartEvent,
    FairLaunchEndEvent,
    QuickLaunchEvent,
    RandomLaunchStartEvent,
    RandomLaunchEndEvent,
    BuyEvent,
    SellEvent,
    LiquidationEvent,
    FlashLoanEvent,
    BuyTicketEvent,
    FeeUpdateEvent,
    BurnEvent,
    AddLiquidityEvent,
    RemoveLiquidityEvent,
    HookEnabledEvent,
    HookDisabledEvent,
)]
#[types(
    CreatorData,
    FlashLoanData,
    String,
    bool,
    ResourceAddress,
    PoolStruct,
    HookInfo,
    HookableOperation,
    Vec<String>,
    IntegratorData,
    u64,
    Vault,
)]
mod radix_pump {

    enable_method_auth! {
        methods {
            forbid_symbols => restrict_to: [OWNER];
            forbid_names => restrict_to: [OWNER];
            update_fees => restrict_to: [OWNER];
            owner_set_liquidation_mode => restrict_to: [OWNER];
            update_time_limits => restrict_to: [OWNER];
            register_hook => restrict_to: [OWNER];
            unregister_hook => restrict_to: [OWNER];
            owner_enable_hook => restrict_to: [OWNER];
            owner_disable_hook => restrict_to: [OWNER];
            new_integrator => restrict_to: [OWNER];
            update_dapp_definition => restrict_to: [OWNER];
            get_badges => restrict_to: [OWNER];

            new_fair_launch => PUBLIC;
            new_quick_launch => PUBLIC;
            new_random_launch => PUBLIC;
            new_pool => restrict_to: [OWNER];
            new_launched_pool => restrict_to: [OWNER];

            creator_set_liquidation_mode => PUBLIC;
            update_pool_fees => PUBLIC;
            launch => PUBLIC;
            terminate_launch => PUBLIC;
            unlock => PUBLIC;
            creator_enable_hook => PUBLIC;
            creator_disable_hook => PUBLIC;
            burn => PUBLIC;

            get_flash_loan => PUBLIC;
            return_flash_loan => PUBLIC;
            buy_ticket => PUBLIC;
            redeem_ticket => PUBLIC;
            add_liquidity => PUBLIC;
            remove_liquidity => PUBLIC;
            swap => PUBLIC;

            get_pool_info => PUBLIC;

            get_fees => PUBLIC;
        }
    }

    enable_package_royalties! {
        new => Free;

        forbid_symbols => Free;
        forbid_names => Free;
        update_fees => Free;
        owner_set_liquidation_mode => Free;
        update_time_limits => Free;
        register_hook => Free;
        unregister_hook => Free;
        owner_enable_hook => Free;
        owner_disable_hook => Free;
        new_integrator => Free;
        update_dapp_definition => Free;
        get_badges => Free;

        new_fair_launch => Usd(dec!("0.05"));
        new_quick_launch => Usd(dec!("0.05"));
        new_random_launch => Usd(dec!("0.05"));
        new_pool => Free;
        new_launched_pool => Free;

        creator_set_liquidation_mode => Free;
        update_pool_fees => Free;
        launch => Free;
        terminate_launch => Free;
        unlock => Usd(dec!("0.005"));
        creator_enable_hook => Free;
        creator_disable_hook => Free;
        burn => Free;

        get_flash_loan => Usd(dec!("0.002"));
        return_flash_loan => Free;
        buy_ticket => Usd(dec!("0.005"));
        redeem_ticket => Free;
        add_liquidity => Free;
        remove_liquidity => Free;
        swap => Usd(dec!("0.005"));

        get_pool_info => Free;

        get_fees => Free;
    }

    struct RadixPump {
        // Resource address of the owner badge
        owner_badge_address: ResourceAddress,

        // Resource address of the coin used as a base in all the pools and used to pay fees
        base_coin_address: ResourceAddress,

        // Minimum amount of base coins to be deposited to do a quick launch
        minimum_deposit: Decimal,

        // Resource Manager for minting creators badges
        creator_badge_resource_manager: ResourceManager,

        // Resource manager for minting the transient NFT used in flash loans
        flash_loan_nft_resource_manager: ResourceManager,

        // Id of the next creator badge to create
        next_creator_badge_id: u64,

        // Id of the last transient NFT created
        last_transient_nft_id: u64,

        // Names and symbols that can't be used in new coins creation. The bool value has no real
        // use.
        forbidden_symbols: KeyValueStore<String, bool>,
        forbidden_names: KeyValueStore<String, bool>,

        // KeyValueStore containing informations about all of the created pools
        pools: KeyValueStore<ResourceAddress, PoolStruct>,

        // Percentage fees paid to the component owner or to an integrator to create a new coin and
        // to buy or sell coins
        creation_fee_percentage: Decimal,
        buy_sell_fee_percentage: Decimal,

        // Fees (in base coins) paid to the component owner or to an integrator when doing a flash
        // loan
        flash_loan_fee: Decimal,

        // Coin creators are not allowed to set buy and sell pool fees higher than this
        max_buy_sell_pool_fee_percentage: Decimal,

        // Minimum duration (in seconds) of the launch phase of a fair launch or random launch
        min_launch_duration: i64,

        // Minimum duration (in seconds) of the locking period of fair launched and random launched
        // coins
        min_lock_duration: i64,

        // Vault to hold the badge for authentication towards pools
        proxy_badge_vault: FungibleVault,

        // Vault to hold the badge for hook to Pool authentication
        hook_badge_vault: FungibleVault,

        // KeyValueStore containing information about all of the hooks allowed by the component owner
        registered_hooks: HookByName,

        // Operation -> hooks associations allowed by the component owner
        registered_hooks_operations: HooksPerOperation,

        // This data structure contains the list of globally enabled hooks for each operation
        globally_enabled_hooks: HooksPerOperation,

        // Resource managed to mint integrator badges
        integrator_badge_resource_manager: ResourceManager,

        // This KVS contain the vaults where the fees are collected
        // Key 0 contains the fees paid to the component owner
        // Key N contains the fees paid to the integrator with badge id N
        fee_vaults: KeyValueStore<u64, Vault>,

        // Numeric id of the next integrator badge to create
        next_integrator_badge_id: u64,

        // dApp definition account address for components and resources
        dapp_definition: ComponentAddress,
    }

    impl RadixPump {

        // RadixPump component instantiation
        pub fn new(
            // Resource address of the owner badge
            owner_badge_address: ResourceAddress,

            // Resource address of the coin used as a base in all the pools and used to pay fees
            base_coin_address: ResourceAddress,

            // Minimum amount of base coins to be deposited to do a quick launch
            minimum_deposit: Decimal,

            // Percentage fees paid to the component owner or to an integrator to create a new coin
            creation_fee_percentage: Decimal,

            // Percentage fees paid to the component owner or to an integrator to buy and sell
            // coins
            buy_sell_fee_percentage: Decimal,

            // Fixed fee (in base coins) paid to the component owner or to an integrator to get a
            // flash loan
            flash_loan_fee: Decimal,

            // dApp definition account address for components and resources
            dapp_definition: ComponentAddress,
        ) -> Global<RadixPump> {

            // Make sure given parameers make sense
            assert!(
                minimum_deposit > Decimal::ZERO,
                "Minimum deposit can't be zero or less",
            );
            assert!(
                creation_fee_percentage >= Decimal::ZERO && creation_fee_percentage < dec!(100),
                "Creation fee percentage can go from 0 (included) to 100 (excluded)",
            );
            assert!(
                buy_sell_fee_percentage >= Decimal::ZERO && buy_sell_fee_percentage < dec!(100),
                "Buy & sell fee percentage can go from 0 (included) to 100 (excluded)",
            );
            assert!(
                flash_loan_fee >= Decimal::ZERO,
                "Flash loan fee can't be a negative number",
            );

            // Reserve a ComponentAddress for setting rules on resources
            let (address_reservation, component_address) = Runtime::allocate_component_address(RadixPump::blueprint_id());

            // Create a ResourceManager for minting coin creator badges
            let creator_badge_resource_manager = <scrypto::prelude::ResourceBuilder as RadixPumpResourceBuilder>::new_integer_non_fungible_with_registered_type::<CreatorData>(
                OwnerRole::Updatable(rule!(require(owner_badge_address)))
            )
            .metadata(metadata!(
                roles {
                    metadata_setter => rule!(require(owner_badge_address));
                    metadata_setter_updater => rule!(require(owner_badge_address));
                    metadata_locker => rule!(require(owner_badge_address));
                    metadata_locker_updater => rule!(require(owner_badge_address));
                },
                init {
                    "name" => CREATOR_BADGE_NAME, updatable;
                    "dapp_definition" => dapp_definition, updatable;
                }
            ))
            .mint_roles(mint_roles!(
                minter => rule!(require(global_caller(component_address)));
                minter_updater => rule!(require(owner_badge_address));
            ))
            .non_fungible_data_update_roles(non_fungible_data_update_roles!(
                non_fungible_data_updater => rule!(require(global_caller(component_address)));
                non_fungible_data_updater_updater => rule!(require(owner_badge_address));
            ))
            .burn_roles(burn_roles!(
                burner => rule!(allow_all); // Coin creators are allowed to burn their badge for
                                            // maximum decentralization
                burner_updater => rule!(require(owner_badge_address));
            ))
            .create_with_no_initial_supply();

            // Create a ResourceManager for the flash loan transient NFT
            let flash_loan_nft_resource_manager = <scrypto::prelude::ResourceBuilder as RadixPumpResourceBuilder>::new_integer_non_fungible_with_registered_type::<FlashLoanData>(
                OwnerRole::Updatable(rule!(require(owner_badge_address)))
            )
            .metadata(metadata!(
                roles {
                    metadata_setter => rule!(require(owner_badge_address));
                    metadata_setter_updater => rule!(require(owner_badge_address));
                    metadata_locker => rule!(require(owner_badge_address));
                    metadata_locker_updater => rule!(require(owner_badge_address));
                },
                init {
                    "name" => TRANSIENT_NFT_NAME, updatable;
                    "dapp_definition" => dapp_definition, updatable;
                }
            ))
            .mint_roles(mint_roles!(
                minter => rule!(require(global_caller(component_address)));
                minter_updater => rule!(deny_all);
            ))
            .non_fungible_data_update_roles(non_fungible_data_update_roles!(
                non_fungible_data_updater => rule!(deny_all);
                non_fungible_data_updater_updater => rule!(deny_all);
            ))
            .burn_roles(burn_roles!(
                burner => rule!(require(global_caller(component_address))); // Burning the NFT is
                                                                            // the only correct way
                                                                            // to terminate a
                                                                            // transaction once
                                                                            // it is minted
                burner_updater => rule!(deny_all);
            ))
            .deposit_roles(deposit_roles!(
                depositor => rule!(deny_all); // Transient
                depositor_updater => rule!(deny_all);
            ))
            .create_with_no_initial_supply();

            // Mint a single badge that will be used by round 0 and 1 hooks to authenticate towards
            // the Pool components
            let hook_badge_bucket = ResourceBuilder::new_fungible(OwnerRole::Updatable(rule!(require(owner_badge_address))))
            .divisibility(0)
            .metadata(metadata!(
                roles {
                    metadata_setter => rule!(require(owner_badge_address));
                    metadata_setter_updater => rule!(require(owner_badge_address));
                    metadata_locker => rule!(require(owner_badge_address));
                    metadata_locker_updater => rule!(require(owner_badge_address));
                },
                init {
                    "name" => "Hook badge", updatable;
                    "dapp_definition" => dapp_definition, updatable;
                }
            ))
            .mint_roles(mint_roles!(
                minter => rule!(require(global_caller(component_address)));
                minter_updater => rule!(require(owner_badge_address));
            ))
            .burn_roles(burn_roles!(
                burner => rule!(deny_all);
                burner_updater => rule!(require(owner_badge_address));
            ))
            .mint_initial_supply(dec![1]);

            // Mint a single badge that will be used for authentication towards the pools
            let proxy_badge_bucket = ResourceBuilder::new_fungible(OwnerRole::Updatable(rule!(require(owner_badge_address))))
            .divisibility(0)
            .metadata(metadata!(
                roles {
                    metadata_setter => rule!(require(owner_badge_address));
                    metadata_setter_updater => rule!(require(owner_badge_address));
                    metadata_locker => rule!(require(owner_badge_address));
                    metadata_locker_updater => rule!(require(owner_badge_address));
                },
                init {
                    "name" => "Proxy badge", updatable;
                    "dapp_definition" => dapp_definition, updatable;
                }
            ))
            .mint_roles(mint_roles!(
                minter => rule!(require(global_caller(component_address)));
                minter_updater => rule!(require(owner_badge_address));
            ))
            .mint_initial_supply(dec![1]);

            // Create a ResourceManager for minting integrator badges
            let integrator_badge_resource_manager = <scrypto::prelude::ResourceBuilder as RadixPumpResourceBuilder>::new_integer_non_fungible_with_registered_type::<IntegratorData>(
                OwnerRole::Updatable(rule!(require(owner_badge_address)))
            )
            .metadata(metadata!(
                roles {
                    metadata_setter => rule!(require(owner_badge_address));
                    metadata_setter_updater => rule!(require(owner_badge_address));
                    metadata_locker => rule!(require(owner_badge_address));
                    metadata_locker_updater => rule!(require(owner_badge_address));
                },
                init {
                    "name" => INTEGRATOR_BADGE_NAME, updatable;
                    "dapp_definition" => dapp_definition, updatable;
                }
            ))
            .mint_roles(mint_roles!(
                minter => rule!(require(global_caller(component_address)));
                minter_updater => rule!(require(owner_badge_address));
            ))
            .non_fungible_data_update_roles(non_fungible_data_update_roles!(
                non_fungible_data_updater => rule!(require(owner_badge_address));
                non_fungible_data_updater_updater => rule!(require(owner_badge_address));
            ))
            .burn_roles(burn_roles!(
                burner => rule!(deny_all);
                burner_updater => rule!(require(owner_badge_address));
            ))
            .create_with_no_initial_supply();

            // Instantiate the component
            Self {
                owner_badge_address: owner_badge_address,
                base_coin_address: base_coin_address.clone(),
                minimum_deposit: minimum_deposit,
                creator_badge_resource_manager: creator_badge_resource_manager,
                flash_loan_nft_resource_manager: flash_loan_nft_resource_manager,
                next_creator_badge_id: 1,
                last_transient_nft_id: 0,
                forbidden_symbols: <KeyValueStore<String, bool> as RadixPumpKeyValueStore>::new_with_registered_type(),
                forbidden_names: <KeyValueStore<String, bool> as RadixPumpKeyValueStore>::new_with_registered_type(),
                pools: <KeyValueStore<ResourceAddress, PoolStruct> as RadixPumpKeyValueStore>::new_with_registered_type(),
                creation_fee_percentage: creation_fee_percentage,
                buy_sell_fee_percentage: buy_sell_fee_percentage,
                flash_loan_fee: flash_loan_fee,
                max_buy_sell_pool_fee_percentage: dec!(10),
                min_launch_duration: 604800, // One week
                min_lock_duration: 7776000, // Three months
                proxy_badge_vault: FungibleVault::with_bucket(proxy_badge_bucket),
                hook_badge_vault: FungibleVault::with_bucket(hook_badge_bucket),
                registered_hooks: <KeyValueStore<String, HookInfo> as RadixPumpKeyValueStore>::new_with_registered_type(),
                registered_hooks_operations: HooksPerOperation::new(),
                globally_enabled_hooks: HooksPerOperation::new(),
                integrator_badge_resource_manager: integrator_badge_resource_manager,
                fee_vaults: <KeyValueStore<u64, Vault> as RadixPumpKeyValueStore>::new_with_registered_type(),
                next_integrator_badge_id: 1,
                dapp_definition: dapp_definition,
            }
            .instantiate()
            .prepare_to_globalize(OwnerRole::Updatable(rule!(require(owner_badge_address))))
            .with_address(address_reservation)
            .metadata(metadata! {
                init {
                    "name" => DAPP_NAME, updatable;
                    "dapp_definition" => dapp_definition, updatable;
                }
            })
            .globalize()
        }

        // The component owner can prevent users to create coins with well known symbols
        pub fn forbid_symbols(
            &mut self,
            symbols: Vec<String>,
        ) {
            for symbol in symbols.iter() {
                self.forbidden_symbols.insert(symbol.trim().to_uppercase(), false);
            }
        }

        // The component owner can prevent users to create coins with well known name
        pub fn forbid_names(
            &mut self,
            names: Vec<String>,
        ) {
            for name in names.iter() {
                self.forbidden_names.insert(name.trim().to_uppercase(), false);
            }
        }

        // Verify that the fees specified by a coin creator are acceptable
        fn check_fees(
            &mut self,
            buy_pool_fee_percentage: Decimal,
            sell_pool_fee_percentage: Decimal,
            flash_loan_pool_fee: Decimal,
            min_buy_fee_apply: bool,
        ) {
            assert!(
                buy_pool_fee_percentage >= Decimal::ZERO && buy_pool_fee_percentage < self.max_buy_sell_pool_fee_percentage,
                "Buy pool fee percentage can go from 0 (included) to {} (excluded)",
                self.max_buy_sell_pool_fee_percentage,
            );
            assert!(
                sell_pool_fee_percentage >= Decimal::ZERO && sell_pool_fee_percentage < self.max_buy_sell_pool_fee_percentage,
                "Sell pool fee percentage can go from 0 (included) to {} (excluded)",
                self.max_buy_sell_pool_fee_percentage,
            );
            assert!(
                flash_loan_pool_fee >= Decimal::ZERO,
                "Flash loan pool fee can't be a negative number",
            );
            if min_buy_fee_apply {
                assert!(
                    buy_pool_fee_percentage >= MIN_LAUNCH_BUY_FEE,
                    "Buy fee to low to initialize the pool",
                );
            }
        }

        // Verify that the metadata specified by a coin creator are acceptable, then register symbol
        // and name as no longer available, finally return a canonical version of the metadata
        fn check_metadata(
            &mut self,
            mut coin_symbol: String,
            mut coin_name: String,
            mut coin_icon_url: String,
            mut coin_info_url: String,
        ) -> (
            String, // symbol
            String, // name
            String, // icon_url
            String  // info_url
        ) {
            coin_symbol = coin_symbol.trim().to_uppercase();
            assert!(
                coin_symbol.len() > 0,
                "Coin symbol can't be empty",
            );
            assert!(
                coin_symbol.len() <= 5,
                "Symbol too long",
            );
            assert!(
                coin_symbol.chars().all(char::is_alphanumeric),
                "Non alphanumeric characters in symbol",
            );
            assert!(
                self.forbidden_symbols.get(&coin_symbol).is_none(),
                "Symbol already used",
            );
            self.forbidden_symbols.insert(coin_symbol.clone(), true);

            coin_name = coin_name.trim().to_string();
            assert!(
                coin_name.len() > 0,
                "Coin name can't be empty",
            );
            assert!(
                coin_name.len() <= 32,
                "Coin name too long",
            );
            let uppercase_coin_name = coin_name.to_uppercase();
            assert!(
                self.forbidden_names.get(&uppercase_coin_name).is_none(),
                "Name already used",
            );
            self.forbidden_names.insert(uppercase_coin_name, true);

            coin_icon_url = coin_icon_url.trim().to_string();
            coin_info_url = coin_info_url.trim().to_string();

            (coin_symbol, coin_name, coin_icon_url, coin_info_url)
        }

        // Instantiate a pool component to perform a random launch 
        pub fn new_random_launch(
            &mut self,

            // Symbol of the coin to launch
            mut coin_symbol: String,

            // Symbol of the coin to launch
            mut coin_name: String,

            // Icon_url of the coin to launch
            mut coin_icon_url: String,

            // Description of the coin to launch (can be empty)
            coin_description: String,

            // Info_url of the coin to launch (can be empty)
            mut coin_info_url: String,

            // Array of URLs of the socials of the coin (can be empty)
            coin_social_url: Vec<String>,

            // Price of a ticket for the random launch (including pool fees)
            ticket_price: Decimal,

            // Number of tickets that will win a coin share at launch
            winning_tickets: u32,

            // How many coins a winning ticket will receive
            coins_per_winning_ticket: Decimal,

            // Percentage fee paid to the pool when buying coins and tickets
            buy_pool_fee_percentage: Decimal,

            // Percentage fee paid to the pool when selling coins
            sell_pool_fee_percentage: Decimal,

            // Amount of base coins paid to the pool when taking a flash loan
            flash_loan_pool_fee: Decimal,

        ) -> Bucket // Creator badge
        {
            // Verify that the fees specified by the coin creator are acceptable
            self.check_fees(buy_pool_fee_percentage, sell_pool_fee_percentage, flash_loan_pool_fee, true);

            // Verify and normaliize the metadata specified by the coin creator
            (coin_symbol, coin_name, coin_icon_url, coin_info_url) =
                self.check_metadata(coin_symbol, coin_name, coin_icon_url, coin_info_url);

            // Instantiate the pool component
            let (pool, coin_resource_address, lp_resource_address) = Pool::new_random_launch(
                self.owner_badge_address,
                self.proxy_badge_vault.resource_address(),
                self.hook_badge_vault.resource_address(),
                coin_symbol.clone(),
                coin_name.clone(),
                coin_icon_url.clone(),
                coin_description,
                coin_info_url,
                coin_social_url,
                ticket_price,
                winning_tickets,
                coins_per_winning_ticket,
                buy_pool_fee_percentage,
                sell_pool_fee_percentage,
                flash_loan_pool_fee,
                self.next_creator_badge_rule(),
                self.base_coin_address,
                self.dapp_definition,
            );

            // Add the pool information in the pools KVS
            self.pools.insert(
                coin_resource_address,
                PoolStruct {
                    component_address: pool.into(),
                    enabled_hooks: HooksPerOperation::new(),
                    creator_id: self.next_creator_badge_id,
                }
            );

            // Mint a badge for the coin creator containing some information about the
            // coin and the pool and return it
            self.mint_creator_badge(
                coin_resource_address,
                coin_name,
                coin_symbol,
                lp_resource_address,
                UncheckedUrl::of(coin_icon_url),
                PoolMode::WaitingForLaunch,
            )
        }

        // Instantiate a pool component to perform a fair launch 
        pub fn new_fair_launch(
            &mut self,

            // Symbol of the coin to launch
            mut coin_symbol: String,

            // Symbol of the coin to launch
            mut coin_name: String,

            // Icon_url of the coin to launch
            mut coin_icon_url: String,

            // Description of the coin to launch (can be empty)
            coin_description: String,

            // Info_url of the coin to launch (can be empty)
            mut coin_info_url: String,

            // Array of URLs of the socials of the coin (can be empty)
            coin_social_url: Vec<String>,

            // Fixed price of a coin during launch phase (fee excluded)
            launch_price: Decimal,

            // The percentage of coins that will be reserved (locked) for the coin creator
            creator_locked_percentage: Decimal,

            // Percentage fee paid to the pool when buying coins and tickets
            buy_pool_fee_percentage: Decimal,

            // Percentage fee paid to the pool when selling coins
            sell_pool_fee_percentage: Decimal,

            // Amount of base coins paid to the pool when taking a flash loan
            flash_loan_pool_fee: Decimal,

        ) -> Bucket // Creator badge
        {
            // Verify that the fees specified by the coin creator are acceptable
            self.check_fees(buy_pool_fee_percentage, sell_pool_fee_percentage, flash_loan_pool_fee, true);

            // Verify and normaliize the metadata specified by the coin creator
            (coin_symbol, coin_name, coin_icon_url, coin_info_url) =
                self.check_metadata(coin_symbol, coin_name, coin_icon_url, coin_info_url);

            // Instantiate the pool component
            let (pool, coin_resource_address, lp_resource_address) = Pool::new_fair_launch(
                self.owner_badge_address,
                self.proxy_badge_vault.resource_address(),
                self.hook_badge_vault.resource_address(),
                coin_symbol.clone(),
                coin_name.clone(),
                coin_icon_url.clone(),
                coin_description,
                coin_info_url,
                coin_social_url,
                launch_price,
                creator_locked_percentage,
                buy_pool_fee_percentage,
                sell_pool_fee_percentage,
                flash_loan_pool_fee,
                self.next_creator_badge_rule(),
                self.base_coin_address,
                self.dapp_definition,
            );

            // Add the pool information in the pools KVS
            self.pools.insert(
                coin_resource_address,
                PoolStruct {
                    component_address: pool.into(),
                    enabled_hooks: HooksPerOperation::new(),
                    creator_id: self.next_creator_badge_id,
                }
            );

            // Mint a badge for the coin creator containing some information about the
            // coin and the pool and return it
            self.mint_creator_badge(
                coin_resource_address,
                coin_name,
                coin_symbol,
                lp_resource_address,
                UncheckedUrl::of(coin_icon_url),
                PoolMode::WaitingForLaunch,
            )
        }

        // Instantiate a pool component to perform a quick launch 
        pub fn new_quick_launch(
            &mut self,

            // Bucket of base coins to initialize the pool
            mut base_coin_bucket: Bucket,

            // Symbol of the coin to launch
            mut coin_symbol: String,

            // Symbol of the coin to launch
            mut coin_name: String,

            // Icon_url of the coin to launch
            mut coin_icon_url: String,

            // Description of the coin to launch (can be empty)
            coin_description: String,

            // Info_url of the coin to launch (can be empty)
            mut coin_info_url: String,

            // Array of URLs of the socials of the coin (can be empty)
            coin_social_url: Vec<String>,

            // Initial supply of the coin to launch (later it can be reduced, not increased)
            coin_supply: Decimal,

            // Launch price of the coin, both the first buyer and the coin creator will get the
            // coin at this price
            coin_price: Decimal,

            // Percentage fee paid to the pool when buying coins and tickets
            buy_pool_fee_percentage: Decimal,

            // Percentage fee paid to the pool when selling coins
            sell_pool_fee_percentage: Decimal,

            // Amount of base coins paid to the pool when taking a flash loan
            flash_loan_pool_fee: Decimal,

        ) -> (
            Bucket, // Creator badge
            Bucket, // Creator share of the launched coin
            Vec<Bucket>, // Eventual additional buckets created by the hooks
        ) {
            // Make sure the base coin deposit is acceptable
            assert!(
                base_coin_bucket.resource_address() == self.base_coin_address,
                "Wrong base coin deposited",
            );
            assert!(
                base_coin_bucket.amount() >= self.minimum_deposit,
                "Insufficient base coin deposit",
            );

            // Pay the component owner share of the coin deposit
            self.deposit_fee(
                0,
                base_coin_bucket.take_advanced(
                    self.creation_fee_percentage * base_coin_bucket.amount() / 100,
                    WithdrawStrategy::Rounded(RoundingMode::ToZero),
                )
            );

            // Verify that the fees specified by the coin creator are acceptable
            self.check_fees(buy_pool_fee_percentage, sell_pool_fee_percentage, flash_loan_pool_fee, false);

            // Verify and normaliize the metadata specified by the coin creator
            (coin_symbol, coin_name, coin_icon_url, coin_info_url) =
                self.check_metadata(coin_symbol, coin_name, coin_icon_url, coin_info_url);

            // Instantiate the pool component
            let (pool, creator_coin_bucket, hook_argument, event, lp_resource_address) = Pool::new_quick_launch(
                self.owner_badge_address,
                self.proxy_badge_vault.resource_address(),
                self.hook_badge_vault.resource_address(),
                base_coin_bucket,
                coin_symbol.clone(),
                coin_name.clone(),
                coin_icon_url.clone(),
                coin_description,
                coin_info_url,
                coin_social_url,
                coin_supply,
                coin_price,
                buy_pool_fee_percentage,
                sell_pool_fee_percentage,
                flash_loan_pool_fee,
                self.next_creator_badge_rule(),
                self.dapp_definition,
            );

            // Emit a QuickLaunchEvent
            self.emit_pool_event(event, 0);

            // Add the pool information in the pools KVS
            let coin_address = creator_coin_bucket.resource_address();
            self.pools.insert(
                coin_address,
                PoolStruct {
                    component_address: pool.into(),
                    enabled_hooks: HooksPerOperation::new(),
                    creator_id: self.next_creator_badge_id,
                }
            );

            // Mint a badge for the coin creator containing some information about the
            // coin and the pool
            let creator_badge_bucket = self.mint_creator_badge(
                creator_coin_bucket.resource_address(),
                coin_name,
                coin_symbol,
                lp_resource_address,
                UncheckedUrl::of(coin_icon_url),
                PoolMode::Normal,
            );

            // Execute global hooks for the QuickLaunch operation
            let buckets = self.execute_hooks(
                &vec![vec![],vec![],vec![]],
                &hook_argument,
            );

            // Return all of the buckets to the coin creator
            (creator_badge_bucket, creator_coin_bucket, buckets)
        }

        // This method can emit any event created by a pool component.
        // It can also add information (the integrator id) that are not known to the pool
        fn emit_pool_event(
            &self,

            // An enum incapsulating every possible event generated by a pool
            mut event: AnyPoolEvent,

            // The integrator id that eventually has to be added to the event struct
            integrator_id: u64,
        ) {
            match event {
                AnyPoolEvent::FairLaunchStartEvent(ref event) => Runtime::emit_event(*event),
                AnyPoolEvent::FairLaunchEndEvent(ref event) => Runtime::emit_event(*event),
                AnyPoolEvent::QuickLaunchEvent(ref event) => Runtime::emit_event(*event),
                AnyPoolEvent::RandomLaunchStartEvent(ref event) => Runtime::emit_event(*event),
                AnyPoolEvent::RandomLaunchEndEvent(ref event) => Runtime::emit_event(*event),
                AnyPoolEvent::BuyEvent(ref mut event) => {
                    event.integrator_id = integrator_id;
                    Runtime::emit_event(*event);
                },
                AnyPoolEvent::SellEvent(ref mut event) => {
                    event.integrator_id = integrator_id;
                    Runtime::emit_event(*event);
                },
                AnyPoolEvent::LiquidationEvent(ref event) => Runtime::emit_event(*event),
                AnyPoolEvent::FlashLoanEvent(ref mut event) => {
                    event.integrator_id = integrator_id;
                    Runtime::emit_event(*event);
                }
                AnyPoolEvent::BuyTicketEvent(ref event) => Runtime::emit_event(*event),
                AnyPoolEvent::FeeUpdateEvent(ref event) => Runtime::emit_event(*event),
                AnyPoolEvent::BurnEvent(ref event) => Runtime::emit_event(*event),
                AnyPoolEvent::AddLiquidityEvent(ref event) => Runtime::emit_event(*event),
                AnyPoolEvent::RemoveLiquidityEvent(ref event) => Runtime::emit_event(*event),
            }
        }

        // The integrators and the component owner can use this method to withdraw their fees
        pub fn get_fees(
            &mut self,

            // Either an integrator badge proof or an owner badge proof
            proof: Proof,

        ) -> Bucket // Fees collected (base coins)
        {
            let integrator_id: u64;

            // In case proof is an owner badge proof set integrator_id to zero
            if proof.resource_address() == self.owner_badge_address {

                // Is this needed?
                proof.check_with_message(
                    self.owner_badge_address,
                    WRONG_BADGE,
                );

                integrator_id = 0;

            // In case proof is an integrator badge proof get the integrator_id from the badge
            // itself
            } else if proof.resource_address() == self.integrator_badge_resource_manager.address() {
                let checked_proof = proof.check_with_message(
                    self.integrator_badge_resource_manager.address(),
                    WRONG_BADGE,
                );

                integrator_id = match checked_proof.as_non_fungible().non_fungible_local_id() {
                    NonFungibleLocalId::Integer(id) => id.value(),
                    _ => Runtime::panic(SHOULD_NOT_HAPPEN.to_string()),
                };

            // Unknown proof
            } else {
                Runtime::panic(WRONG_BADGE.to_string());
            }

            // Get all of the fees collected for this integrator
            self.fee_vaults.get_mut(&integrator_id).expect("No fees yet").take_all()
        }

        // The component owner can use this method to set the platform fees
        pub fn update_fees(
            &mut self,

            // Percentage fees paid to the component owner or to an integrator to create a new coin
            creation_fee_percentage: Decimal,

            // Percentage fees paid to the component owner or to an integrator to buy and sell
            // coins
            buy_sell_fee_percentage: Decimal,

            // Fixed fee (in base coins) paid to the component owner or to an integrator to get a
            // flash loan
            flash_loan_fee: Decimal,

            // Upper limit to the buy and sell pool fees a coin creator can set
            max_buy_sell_pool_fee_percentage: Decimal,

            // Minimum amount of base coins to be deposited to do a quick launch
            minimum_deposit: Decimal,
        ) {
            // Make sure the parameters make sense
            assert!(
                creation_fee_percentage >= Decimal::ZERO && creation_fee_percentage < dec!(100),
                "Creation fee percentage can go from 0 (included) to 100 (excluded)",
            );  
            assert!(
                buy_sell_fee_percentage >= Decimal::ZERO && buy_sell_fee_percentage < dec!(100),
                "Buy & sell fee percentage can go from 0 (included) to 100 (excluded)",
            );
            assert!(
                flash_loan_fee >= Decimal::ZERO,
                "Flash loan fee can't be a negative number",
            );
            assert!(
                max_buy_sell_pool_fee_percentage >= Decimal::ZERO && max_buy_sell_pool_fee_percentage <= dec!(100),
                "Max buy sell pool fee percentage can go from 0 (included) to 100 (included)",
            );
            assert!(
                minimum_deposit > Decimal::ZERO,
                "Minimum_deposit can't be zero or less",
            );

            // Update the component state with the new values
            self.creation_fee_percentage = creation_fee_percentage;
            self.buy_sell_fee_percentage = buy_sell_fee_percentage;
            self.flash_loan_fee = flash_loan_fee;
            self.max_buy_sell_pool_fee_percentage = max_buy_sell_pool_fee_percentage;
            self.minimum_deposit = minimum_deposit;
        }

        // The component owner can use this method to put a pool in liquidation mode
        pub fn owner_set_liquidation_mode(
            &mut self,

            // address of the coin whose pool will be set in liquidation mode
            coin_address: ResourceAddress,
        ) {
            // Find information on the pool to operate on
            let mut pool = self.pools.get_mut(&coin_address).expect(COIN_NOT_FOUND);

            // Use the proxy badge to call the set_liquidation_mode pool method
            let (mode, event) = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.set_liquidation_mode()
            );

            // Get the creator badge id then drop the pool variable to avoid borrow conflicts
            let creator_id = pool.creator_id;
            drop(pool);

            // Emit a LiquidationEvent
            self.emit_pool_event(event, 0);

            // Update pool_mode in the creator badge NFT
            self.update_mode_in_creator_nft(creator_id, mode);
        }

        // A coin creator can use this method to put his pool in liquidation mode
        pub fn creator_set_liquidation_mode(
            &mut self,

            // Creator badge proof
            creator_proof: Proof,
        ) {
            // Get all of the badge information from the proof
            let (creator_id, creator_data) = self.get_creator_data(creator_proof);

            // Find the pool to operate on
            let mut pool = self.pools.get_mut(&creator_data.coin_resource_address).expect(COIN_NOT_FOUND);

            // Use the proxy badge to call the set_liquidation_mode pool method
            let (mode, event) = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.set_liquidation_mode()
            );

            // Dop the pool variable to avoid borrow conflicts
            drop(pool);

            // Emit a LiquidationEvent
            self.emit_pool_event(event, 0);

            // Update pool_mode in the creator badge NFT
            self.update_mode_in_creator_nft(creator_id, mode);
        }

        // Use this method to get a flash loan of one of the coins created through this component
        // This method mints a transient NFT that must be burned by calling the return_flash_loan
        // method or the transaction will fail
        pub fn get_flash_loan(
            &mut self,

            // The address of the coin to borrow
            coin_address: ResourceAddress,

            // The amount of coins to borrow
            amount: Decimal
        ) -> (
            Bucket, // Coin bucket
            Bucket, // Transient NFT
        ) {
            // Find the pool holding the coin
            let mut pool = self.pools.get_mut(&coin_address).expect(COIN_NOT_FOUND);

            // Use the proxy badge to call the get_flash_loan pool method
            let coin_bucket = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.get_flash_loan(amount)
            );

            // Dop the pool variable to avoid borrow conflicts
            drop(pool);

            // Mint a transient NFT containing information about the loan
            self.last_transient_nft_id += 1;
            let transient_nft_bucket = self.flash_loan_nft_resource_manager.mint_non_fungible(
                &NonFungibleLocalId::integer(self.last_transient_nft_id),
                FlashLoanData {
                    coin_resource_address: coin_address,
                    coin_amount: amount,
                }
            );

            // Reurn both buckets to the user
            (coin_bucket, transient_nft_bucket)
        }

        // Use this method to return a flash loan and burn the transient NFT
        pub fn return_flash_loan(
            &mut self,

            // A bucket containing a single transient NFT to burn
            transient_nft_bucket: Bucket,

            // A bucket containig base coins to pay both owner (or integrator) and pool fees
            mut base_coin_bucket: Bucket,

            // A bucket containing the coins to return
            coin_bucket: Bucket,

            // The id of the integrator whose interface has been used
            mut integrator_id: u64,

        ) -> Vec<Bucket> // Eventual buckets created by hooks
        {
            // Make sure the resources are the correct ones
            assert!(
                transient_nft_bucket.resource_address() == self.flash_loan_nft_resource_manager.address(),
                "Wrong NFT",
            );
            assert!(
                base_coin_bucket.resource_address() == self.base_coin_address,
                "Wrong base coin",
            );

            // Make sure that the integrator_id is valid (or zero)
            integrator_id = self.check_integrator_id(integrator_id);

            // Read loan information from the transient NFT and check them
            let flash_loan_data = transient_nft_bucket.as_non_fungible().non_fungible::<FlashLoanData>().data();
            assert!(
                flash_loan_data.coin_resource_address == coin_bucket.resource_address(),
                "Wrong coin",
            );
            assert!(
                flash_loan_data.coin_amount <= coin_bucket.amount(),
                "Not enough coins",
            );

            // Burn the transient NFT
            transient_nft_bucket.burn();

            // Deposit component owner (or integrator) fees
            self.deposit_fee(
                integrator_id,
                base_coin_bucket.take_advanced(
                    self.creation_fee_percentage * base_coin_bucket.amount() / 100,
                    WithdrawStrategy::Rounded(RoundingMode::ToZero),
                )
            );

            // Find the pool to return the loan to
            let mut pool = self.pools.get_mut(&coin_bucket.resource_address()).unwrap();

            // Use the proxy badge to call the return_flash_loan method of the pool
            let (hook_argument, event) = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.return_flash_loan(
                    base_coin_bucket,
                    coin_bucket,
                )
            );

            // Get the list of hooks enabled for this pool for the ReturnFlashLoan operation
            let pool_enabled_hooks = pool.enabled_hooks.get_all_hooks(hook_argument.operation);

            // Drop the pool variable to avoid conflicts with borrows
            drop(pool);

            // Emit the FlashLoanEvent
            self.emit_pool_event(event, integrator_id);

            // Execute the hooks and return the eventual received buckets
            self.execute_hooks(
                &pool_enabled_hooks,
                &hook_argument,
            )
        }

        // A coin creator can use this method to update the fees of his pool
        pub fn update_pool_fees(
            &mut self,

            // Coin creator badge proof
            creator_proof: Proof,

            // New fees to set
            buy_pool_fee_percentage: Decimal,
            sell_pool_fee_percentage: Decimal,
            flash_loan_pool_fee: Decimal,
        ) {
            // Check that the fees are acceptable
            self.check_fees(
                buy_pool_fee_percentage,
                sell_pool_fee_percentage,
                flash_loan_pool_fee,
                false,
            );

            // Read the badge information from the proof
            let (_, creator_data) = self.get_creator_data(creator_proof);

            // Find the pool to operate on
            let mut pool = self.pools.get_mut(&creator_data.coin_resource_address).unwrap();

            // Use the proxy badge to call the update_pool_fees method of the pool
            let event = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.update_pool_fees(
                    buy_pool_fee_percentage,
                    sell_pool_fee_percentage,
                    flash_loan_pool_fee,
                )
            );

            // DRop the pool variable to avoid borrow conflicts
            drop(pool);

            // Emit the FeeUpdateEvent event
            self.emit_pool_event(event, 0);
        }

        // Read only method to get all of the info about a pool
        pub fn get_pool_info(
            &self,

            // The address of the coin to get information on
            coin_address: ResourceAddress,

        ) -> PoolInfo // This struct contains all of the info
        {
            // Find the pool to get information on
            let pool = self.pools.get(&coin_address).expect(COIN_NOT_FOUND);

            // Get a PoolInfo from the pool, it must be mut so this method can add the missing
            // information
            let mut pool_info = pool.component_address.get_pool_info();

            // Add the RadixPump component fees to the pool fees to get the total fees
            pool_info.total_buy_fee_percentage = dec!(1000000) / ((100 - pool_info.total_buy_fee_percentage) * (100 - self.buy_sell_fee_percentage)) - dec!(100);
            pool_info.total_sell_fee_percentage = pool_info.total_sell_fee_percentage + self.buy_sell_fee_percentage * (100 - pool_info.total_sell_fee_percentage) / dec!(100);
            pool_info.total_flash_loan_fee = pool_info.total_flash_loan_fee + self.flash_loan_fee;

            // Add information about the badges used by RadixPump
            pool_info.flash_loan_nft_resource_address = Some(self.flash_loan_nft_resource_manager.address());
            pool_info.hooks_badge_resource_address = Some(self.hook_badge_vault.resource_address());
            pool_info.creator_badge_resource_address = Some(self.creator_badge_resource_manager.address());

            // Return the struct cointaining all of the info
            pool_info
        }

        // Check a creator badge proof and extract NonFungibleLocalId and NonFungibleData from it
        fn get_creator_data(
            &self,

            // The creator badge proof to check
            creator_proof: Proof
        ) -> (
            u64, // numeric value of the NonFungibleLocalId
            CreatorData, // NonFungibleData
        ) {
            // Check the proof or die
            let non_fungible = creator_proof.check_with_message(
                self.creator_badge_resource_manager.address(),
                WRONG_BADGE,
            )
            .as_non_fungible()
            .non_fungible::<CreatorData>();

            // Get the numeric value of the NonFungibleLocalId
            let local_id = match &non_fungible.local_id() {
                NonFungibleLocalId::Integer(local_id) => local_id.value(),
                _ => Runtime::panic(SHOULD_NOT_HAPPEN.to_string()),
            };

            // Return NonFungibleLocalId and NonFungibleData
            (local_id, non_fungible.data())
        }

        // The component owner can use this method to update time limits on fair and random
        // launches
        pub fn update_time_limits(
            &mut self,

            // Minimum number of seconds a fair or random launch must last
            min_launch_duration: i64,

            // Minimum number of seconds the creator allocation will be locked in fair and random
            // launches
            min_lock_duration: i64,
        ) {
            assert!(
                min_launch_duration > 0,
                "Min launch duration must be bigger than zero",
            );
            self.min_launch_duration = min_launch_duration;

            assert!(
                min_lock_duration > 0,
                "Min lock duration must be bigger than zero",
            );
            self.min_lock_duration = min_lock_duration;
        }

        // The new_*_lunch methods create pools in the WaitingForLaunch state
        // Random and fair launched coin creators can use this method to actually launch their
        // coins
        pub fn launch(
            &mut self,

            // Coin creator badge proof
            creator_proof: Proof,

            // Minimum end launch date and time to set
            end_launch_time: i64,

            // Date and time of the complete unlock of creator funds
            unlocking_time: i64,

        ) -> Vec<Bucket> // Eventual buckets returned by the hooks
        {
            // Make sure the miminum periods are respected
            assert!(
                end_launch_time >= Clock::current_time_rounded_to_seconds().seconds_since_unix_epoch + self.min_launch_duration,
                "Launch time too short",
            );
            assert!(
                unlocking_time >= end_launch_time + self.min_lock_duration,
                "Lock time too short",
            );

            // Extract information from the creator badge proof
            let (creator_id, creator_data) = self.get_creator_data(creator_proof);
            let coin_address = creator_data.coin_resource_address;

            // Find the pool to operate on
            let mut pool = self.pools.get_mut(&coin_address).unwrap();

            // Use the proxy badge to call the launch method of the pool component
            let (mode, hook_argument, event) = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.launch(end_launch_time, unlocking_time)
            );

            // Get the hooks enabled for this operation on the pool
            let pool_enabled_hooks = pool.enabled_hooks.get_all_hooks(hook_argument.operation);

            // Drop the pool variable to avoid borrow conflicts
            drop(pool);

            // Emit a FairLaunchStartEvent or a RandomLaunchStartEvent
            self.emit_pool_event(event, 0);

            // Update pool_mode in the coin creator badge
            self.update_mode_in_creator_nft(creator_id, mode);

            // Execute hooks and return the received buckets
            self.execute_hooks(
                &pool_enabled_hooks,
                &hook_argument,
            )
        }

        // This method merges the globally enabled hooks list with the pool enabled one and
        // executes them.
        // The hooks are organized in 3 different rounds (more information in the common.rs file).
        fn execute_hooks(
            &mut self,

            // Array of hooks divided by round
            pool_enabled_hooks: &Vec<Vec<String>>,

            // Information about the operation that caused this hook invocation; this will be
            // passed to the hooks
            hook_argument: &HookArgument,

        ) -> Vec<Bucket>
        {
            // Initialize an array of buckets to return
            let mut additional_buckets: Vec<Bucket> = vec![];

            // Get the hook badge from the vault
            let mut hook_badge_bucket: Option<FungibleBucket> = Some(self.hook_badge_vault.take(dec!(1)));

            // Initialize an array that will contain hooks triggered by other hooks
            // The first vector will always be empty: a round 0 hook can trigger a round 1 or round
            // 2 hook
            let mut additional_operations_round: Vec<Vec<(HookArgument, HookInterfaceScryptoStub)>> = vec![vec![],vec![],vec![]];

            // For each execution round
            for execution_round in 0..3 {

                // Merge the hooks enabled by the component owner with the ones enabled by the coin
                // creator
                let merged_hooks = self.globally_enabled_hooks.merge(
                    hook_argument.operation,
                    &pool_enabled_hooks[execution_round],
                    execution_round,
                );

                // Extract only the hooks enabled for the current operation
                let registered_hooks_per_operation =
                    self.registered_hooks_operations.get_hooks(hook_argument.operation, execution_round);

                // For each hook
                for hook in merged_hooks.iter() {

                    // Search it in the registered list
                    let hook_info = self.registered_hooks.get_mut(&hook);

                    // Ignore hoooks that have been unregistered by the componet owner; do not panic
                    if hook_info.is_none() || !registered_hooks_per_operation.iter().any(|x| x == hook) {
                        continue;
                    }

                    // Use the proxy badge to call the hook
                    let (
                        temp_badge_bucket,
                        opt_bucket,
                        events,
                        hook_arguments,
                    ) = self.proxy_badge_vault.authorize_with_amount(
                        1,
                        || hook_info.unwrap().deref_mut().component_address.hook(
                            hook_argument.clone(),
                            hook_badge_bucket,
                        )
                    );

                    // Verify that the hook returned the badge if provided
                    if execution_round < 2 {
                        assert!(
                            temp_badge_bucket.as_ref().unwrap().resource_address() == self.hook_badge_vault.resource_address() &&
                            temp_badge_bucket.as_ref().unwrap().amount() == Decimal::ONE,
                            "Hey hook, where's my badge gone?",
                        );
                    }
                    hook_badge_bucket = temp_badge_bucket;

                    // An hook can generate any number of Pool events by calling Pool methods
                    for event in events.iter() {
                        self.emit_pool_event(event.clone(), 0);
                    }

                    // An hook may return a Bucket for the user, if so add it to the vector
                    match opt_bucket {
                        None => {},
                        Some(bucket) => additional_buckets.push(bucket),
                    }

                    match execution_round {
                        0 => {

                            // A round 0 hook can recursively trigger the execution of other hooks
                            for argument in hook_arguments.iter() {

                                // An hook executed on a pool can also trigger hooks on different
                                // pools!
                                let pool2 = self.pools.get(&argument.coin_address);

                                match pool2 {
                                    None => {},
                                    Some(pool2) => {
                                        let pool2_enabled_hooks = pool2.enabled_hooks.get_all_hooks(argument.operation);

                                        // For execution rounds 1 and 2
                                        for execution_round2 in 1..3 {

                                            // Get all of the hook enabled for the operation
                                            // globally or for the pool
                                            let merged_hooks = self.globally_enabled_hooks.merge(
                                                argument.operation,
                                                &pool2_enabled_hooks[execution_round2],
                                                execution_round2,
                                            );
                                            for hook2 in merged_hooks.iter() {
                                                let hook2_info = self.registered_hooks.get(&hook2);

                                                // Select only the registered hooks that allow
                                                // recursion
                                                match hook2_info {
                                                    None => {},
                                                    Some(hook2_info) => {
                                                        if !hook2_info.allow_recursion || hook2_info.round == 0 {
                                                            continue;
                                                        }

                                                        // Put them into an array for later use
                                                        additional_operations_round[hook2_info.round].push(
                                                            (argument.clone(), hook2_info.component_address)
                                                        );
                                                    },
                                                }
                                            }
                                        }
                                    },
                                }
                            }
                        },
                        1 | 2 => {

                            // In rounds 1 and 2 execute the additional hooks too
                            for op in additional_operations_round[execution_round].iter_mut() {
                                let (
                                    temp_badge_bucket,
                                    opt_bucket,
                                    events,
                                    _,
                                ) = self.proxy_badge_vault.authorize_with_amount(
                                    1,
                                    || op.1.hook(
                                        op.0.clone(),
                                        hook_badge_bucket,
                                    )
                                );

                                // Verify that the hook returned the badge if provided
                                if execution_round < 2 {
                                    assert!(
                                        temp_badge_bucket.as_ref().unwrap().resource_address() == self.hook_badge_vault.resource_address() &&
                                        temp_badge_bucket.as_ref().unwrap().amount() == Decimal::ONE,
                                        "Hey hook, where's my badge gone?",
                                    );
                                }
                                hook_badge_bucket = temp_badge_bucket;

                                // An hook can generate any number of Pool events by calling Pool methods
                                for event in events.iter() {
                                    self.emit_pool_event(event.clone(), 0);
                                }

                                // An hook may return a Bucket for the user, if so add it to the
                                // vector
                                match opt_bucket {
                                    None => {},
                                    Some(bucket) => additional_buckets.push(bucket),
                                }
                            }
                        },
                        _ => {},
                    }
                }

                // At the end of round 1 put the badge back to rest
                if execution_round == 1 {
                    self.hook_badge_vault.put(hook_badge_bucket.unwrap());
                    hook_badge_bucket = None;
                }
            }

            // Return all of the buckets to the user
            additional_buckets
        }

        // The creator of a fair or random launched coin can use this method to terminate the
        // launch phase
        // A Random launched coin may require two or more invocations of this method to actually
        // go into the Normal mode, this is why both return values are Option: only the last
        // invocation will return non None values
        pub fn terminate_launch(
            &mut self,

            // Coin creator badge proof
            creator_proof: Proof,

        ) -> (
            Option<Bucket>, // Launch proceeds (base coins)
            Option<Vec<Bucket>>, // Additional buckets eventually returned by hooks
        ) {
            // Extract information from the creator proof
            let (creator_id, creator_data) = self.get_creator_data(creator_proof);
            let coin_address = creator_data.coin_resource_address;

            // Find the pool to operate on
            let mut pool = self.pools.get_mut(&coin_address).unwrap();

            // Use the proxy badge to call the terminate_launch method of the pool
            let (mut bucket, mode, hook_argument, event) = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.terminate_launch()
            );

            // The method may return Some(hook_argument) or None
            let pool_enabled_hooks = match hook_argument {
                None => None,
                Some(ref hook_argument) => 
                    Some(pool.enabled_hooks.get_all_hooks(hook_argument.operation)),
            };

            // Drop the pool variable to avoid conflicts in multiple borrows
            drop(pool);

            // If a FairLaunchEndEvent or RandomLaunchEndEvent event is returned emit it
            if event.is_some() {
                self.emit_pool_event(event.unwrap(), 0);
            }

            // If the pool mode has changed update the pool_mode field in the coin creator badge
            if mode.is_some() {
                self.update_mode_in_creator_nft(creator_id, mode.unwrap());
            }

            // If hook_argument is Some, execute relevant hooks
            let buckets = match hook_argument {
                None => None,
                Some(ref hook_argument) => {
                    Some(
                        self.execute_hooks(
                            &pool_enabled_hooks.unwrap(),
                            &hook_argument,
                        )
                    )
                },
            };

            // If the pool returned a base coin bucket extract the fees from it
            match bucket {
                None => {},
                Some(ref mut bucket) => {
                    self.deposit_fee(
                        0,
                        bucket.take_advanced(
                            self.creation_fee_percentage * bucket.amount() / 100,
                            WithdrawStrategy::Rounded(RoundingMode::ToZero),
                        )
                    );
                }
            }

            // Return all of the received hooks
            (bucket, buckets)
        }

        // This private method mints a new coin creator badge, it contains some the information
        // about the pool and the coin
        fn mint_creator_badge(
            &mut self,

            // Resource address of the coin created by the owner of this badge
            coin_resource_address: ResourceAddress,

            // Name of the coin created by the owner of this badge
            coin_name: String,

            // Symbol of the coin created by the owner of this badge
            coin_symbol: String,

            // Resource address of the liquidity token created by the owner of this badge
            lp_token_address: ResourceAddress,

            // URL of the icon of the coin created by the owner of this badge
            key_image_url: UncheckedUrl,

            // Current mode of the pool created by the owner of this badge
            pool_mode: PoolMode

        ) -> Bucket // The minted creator badge
        {
            let creator_badge = self.creator_badge_resource_manager.mint_non_fungible(
                &NonFungibleLocalId::integer(self.next_creator_badge_id.into()),
                CreatorData {
                    coin_resource_address: coin_resource_address,
                    coin_name: coin_name,
                    coin_symbol: coin_symbol,
                    creation_date: Clock::current_time_rounded_to_seconds(),
                    lp_token_address: lp_token_address,
                    key_image_url: key_image_url,
                    pool_mode: pool_mode,
                }
            );

            self.next_creator_badge_id += 1;

            creator_badge
        }

        // All of the coin creator badges have the same resource address, what makes them different
        // one from the other is the NonFungibleLocalId
        // This private method creates an AccessRuleNode that combines the resource address of the
        // creator badge with the NonFungibleLocalId of the next badge that will be minted, use
        // this AccessRuleNode as owner for the resources that will be created
        fn next_creator_badge_rule(&mut self) -> AccessRuleNode {
            AccessRuleNode::ProofRule(
                ProofRule::Require (
                    ResourceOrNonFungible::NonFungible (
                        NonFungibleGlobalId::new(
                            self.creator_badge_resource_manager.address(),
                            NonFungibleLocalId::integer(self.next_creator_badge_id.into()),
                        )
                    )
                )
            )
        }

        // A coin creator can use this method to get (part of) his coin allocation
        pub fn unlock(
            &mut self,

            // Coin creator badge proof
            creator_proof: Proof,

            // Amount required or None (all of the available amount)
            amount: Option<Decimal>,

            // Whether to sell or not the coins received
            sell: bool,
        ) -> (
            Bucket, // Coins (if sell is false) or base coins (if sell is true)
            Vec<Bucket>, // Eventual additional buckets created by the hooks
        ) {
            // Get the coin address from the creator badge proof
            let coin_address = self.get_creator_data(creator_proof).1.coin_resource_address;

            // Find the pool of the coin
            let mut pool = self.pools.get_mut(&coin_address).unwrap();

            // Use the proxy badge to call the unlock method of the pool
            let coin_bucket = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.unlock(amount)
            );

            match sell {
                // If sell is false just return the received coins and call no hooks
                false => (coin_bucket, vec![]),

                // If sell is true
                true => {
                    // Use the proxy badge to call the sell method of the pool
                    let (mut base_coin_bucket, hook_argument, event) =
                        self.proxy_badge_vault.authorize_with_amount(
                            1,
                            || pool.component_address.sell(coin_bucket)
                        );

                    // Get the hook list for the Sell operation on the pool
                    let pool_enabled_hooks = pool.enabled_hooks.get_all_hooks(hook_argument.operation);

                    // Drop the pool variable to prevent problems with borrow
                    drop(pool);

                    // Emit the SellEvent
                    self.emit_pool_event(event, 0);

                    // Esecute hooks for the Sell operation
                    let buckets = self.execute_hooks(
                        &pool_enabled_hooks,
                        &hook_argument,
                    );

                    // Take the fees owed to the component owner for the sell operation
                    self.deposit_fee(
                        0,
                        base_coin_bucket.take_advanced(
                            base_coin_bucket.amount() * self.buy_sell_fee_percentage / dec!(100),
                            WithdrawStrategy::Rounded(RoundingMode::ToZero),
                        )
                     );

                    (base_coin_bucket, buckets)
                },
            }
        }

        // The component owner can use this method to allow the use of a hook component in response 
        // to one or more operation.
        // This method doesn't enable the hook: the owner_enable_hook or creator_enable_hook
        // methods must be called after the hook has been registered to actually enable it
        pub fn register_hook(
            &mut self,

            // Name that will identify the hook component from now on
            name: String,

            // List of the operations this hook can be attached to.
            // The string operations are converted into HookableOperation
            operations: Vec<String>,

            // Address of the hook component
            component_address: HookInterfaceScryptoStub,
        ) {
            // Call the hook to know in which round it wants to be executed and if other hooks
            // trigger his call
            let (round, allow_recursion) = component_address.get_hook_info();
            assert!(
                round < 3,
                "Non existent round",
            );
            assert!(
                round != 0 || !allow_recursion,
                "Round 0 hooks can't be called recursively",
            );

            // Register the hook as available for the specified operations
            self.registered_hooks_operations.add_hook(
                &name,
                &operations,
                round
            );

            // Add the hook information in the registered_hooks KVS
            self.registered_hooks.insert(
                name,
                HookInfo {
                    component_address: component_address,
                    round: round,
                    allow_recursion: allow_recursion,
                },
            );
        }

        // The component owner can use this method to make an hook non available for the specified
        // operations or for all of the operations
        pub fn unregister_hook(
            &mut self,

            // Name of a previously registered hook
            name: String,

            // List of the operations to disable the hook for or all None (means all of the
            // operations)
            // The string operations are converted into HookableOperation
            operations: Option<Vec<String>>,
        ) {
            // Search the hook by name in the registered_hooks KVS
            let hook_info = self.registered_hooks.get(&name);

            match hook_info {
                // If not found there's nothing to do
                None => {},

                // If found
                Some(hook_info) => {
                    match operations {
                        // In case no operation is specified completely remove the hook from the
                        // registered hooks KVS
                        None => {
                            self.registered_hooks.remove(&name);
                        },

                        Some(operations) =>
                            // If one or more operations are specified, unregister the hook only
                            // for these operations
                            self.registered_hooks_operations.remove_hook(
                                &name,
                                &operations,
                                hook_info.round,
                            ),
                    }
                },
            }
        }

        // The component owner can use this method to globally enable an hook for all coins
        pub fn owner_enable_hook(
            &mut self,

            // Name of a registered hook
            name: String,

            // Operations to enable the hook for
            // The string operations are converted into HookableOperation
            operations: Vec<String>,
        ) {
            // Search the hook by name
            let hook_info = self.registered_hooks.get(&name).expect(UNKNOWN_HOOK);

            // For each operation to enable the hook for, make sure that the hook is registered for
            // that operation; panic if it isn't
            for operation in operations.iter() {
                assert!(
                    self.registered_hooks_operations.hook_exists(
                        &name,
                        &operation,
                        hook_info.round,
                    ),
                    "Hook {} not registered for operation {}",
                    name,
                    operation,
                );
            }

            // Enable the hook for all of the specified operations
            self.globally_enabled_hooks.add_hook(
                &name,
                &operations,
                hook_info.round,
            );

            // Emit the HookEnabledEvent event
            Runtime::emit_event(
                HookEnabledEvent {
                    resource_address: None, // No coin specified = globally enabled
                    hook_name: name,
                    hook_address: hook_info.component_address,
                    operations: operations,
                }
            );
        }

        // The component owner can use this method to disable an hook that has been previosly globally enabled
        // This method doesn't disable hooks enable on a specific pool
        pub fn owner_disable_hook(
            &mut self,

            // Name of the hook
            name: String,

            // Operations to disable the hook for
            operations: Vec<String>,
        ) {
            // Search the hook by name
            let hook_info = self.registered_hooks.get(&name).expect(UNKNOWN_HOOK);

            // Disable the hook for the specified operations
            self.globally_enabled_hooks.remove_hook(
                &name,
                &operations,
                hook_info.round,
            );

            // Emit the HookDisabledEvent event
            Runtime::emit_event(
                HookDisabledEvent {
                    resource_address: None, // No coin specified = globally disabled
                    hook_name: name,
                    hook_address: hook_info.component_address,
                    operations: operations,
                }
            );
        }

        // A coin creator can use this method to enable an hook for spcific operations on his pool
        pub fn creator_enable_hook(
            &mut self,

            // Coin creator badge proof
            creator_proof: Proof,

            // Name of a registered hook
            name: String,

            // List of operations to enable the hook for
            // The string operations are converted into HookableOperation
            operations: Vec<String>,
        ) {
            // Search the hook by name
            let hook_info = self.registered_hooks.get(&name).expect(UNKNOWN_HOOK);

            // For each operation to enable the hook for, make sure that the hook is registered for
            // that operation; panic if it isn't
            for operation in operations.iter() {
                assert!(
                    self.registered_hooks_operations.hook_exists(
                        &name,
                        &operation,
                        hook_info.round,
                    ),
                    "Hook {} not registered for operation {}",
                    name,
                    operation,
                );
            }

            // Find the pool of the creator and enable the hook for the specifiled operations
            let coin_address = self.get_creator_data(creator_proof).1.coin_resource_address;
            self.pools.get_mut(&coin_address).unwrap().enabled_hooks.add_hook(
                &name,
                &operations,
                hook_info.round,
            );
            
            // Emit a HookEnabledEvent event
            Runtime::emit_event(
                HookEnabledEvent {
                    resource_address: Some(coin_address),
                    hook_name: name,
                    hook_address: hook_info.component_address,
                    operations: operations,
                }
            );
        }

        // A coin creator can use this method to disable an hook he previously enabled on his pool
        pub fn creator_disable_hook(
            &mut self,

            // Coin creator badge proof
            creator_proof: Proof,

            // Name of the registered hook
            name: String,

            // Operations to disable the hook for
            operations: Vec<String>,
        ) {
            // Search the hook by name
            let hook_info = self.registered_hooks.get(&name).expect(UNKNOWN_HOOK);

            // Find the pool of the creator and disable the hook for the specified operations
            let coin_address = self.get_creator_data(creator_proof).1.coin_resource_address;
            self.pools.get_mut(&coin_address).unwrap().enabled_hooks.remove_hook(
                &name,
                &operations,
                hook_info.round,
            );

            // Emit the HookDisabledEvent event
            Runtime::emit_event(
                HookDisabledEvent {
                    resource_address: Some(coin_address),
                    hook_name: name,
                    hook_address: hook_info.component_address,
                    operations: operations,
                }
            );
        }

        // A pool handling a quick launched coin can have an excess of coins in it; those are
        // called ignored_coins
        // The creator of the quick launched coin can use this method to burn (part of) the
        // ignored_coins in the pool
        pub fn burn(
            &mut self,

            // Coin creator badge proof
            creator_proof: Proof,

            // Maximum amount of coins to burn
            amount: Decimal,
        ) {
            // Find the pool using the info in the proof
            let coin_address = self.get_creator_data(creator_proof).1.coin_resource_address;
            let mut pool = self.pools.get_mut(&coin_address).unwrap();

            // Use the proxy badge to call the burn method of the pool component
            let event = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.burn(amount)
            );

            // Drop the pool variable to avoid problems with multiple borrows
            drop(pool);

            // Emit the BurnEvent returned by the pool
            self.emit_pool_event(event, 0);
        }

        // During the launch phase of a random launched coin, users can call this method to buy
        // tickets to take part in the extraction
        // Tickets are non fungibles: an integer amount of tickets must be bought
        pub fn buy_ticket(
            &mut self,

            // Address of the coin whose launch ticket the user wants to buy
            coin_address: ResourceAddress,

            // Number of tickets the user wants to buy
            amount: u32,

            // Coins to buy the tickets
            coin1_bucket: Bucket,

        ) -> (
            Bucket, // Eventual excess coins
            Bucket, // Tickets
            Vec<Bucket>, // Eventual additional buckets returned by the hooks for the Sell operation
            Vec<Bucket>, // Eventual additional buckets returned by the hooks for the BuyTicket operation
        ) {
            // Check input parameters
            assert!(
                amount > 0,
                "Can't buy zero tickets",
            );

            let (base_coin_bucket, buckets1) = match coin1_bucket.resource_address() == self.base_coin_address {

                // If coin1 is the base coin there's no sell operation
                true => (coin1_bucket, vec![]),

                false => self.sell(coin1_bucket, 0),
            };
 
            // Find the pool
            let mut pool = self.pools.get_mut(&coin_address).expect(COIN_NOT_FOUND);

            // Use the proxy badge to call the buy_ticket method of the pool component
            let (excess_bucket, ticket_bucket, hook_argument, event) =
                self.proxy_badge_vault.authorize_with_amount(
                    1,
                    || pool.component_address.buy_ticket(
                        amount,
                        base_coin_bucket
                    )
                );

            // Get the list of hooks enabled on the pool for the BuyTicket operation
            let pool_enabled_hooks = pool.enabled_hooks.get_all_hooks(hook_argument.operation);

            // Drop the pool to avoid conflicting borrows
            drop(pool);

            // Emit the BuyTicketEvent event
            self.emit_pool_event(event, 0);

            // Execute the hooks
            let buckets2 = self.execute_hooks(
                &pool_enabled_hooks,
                &hook_argument,
            );

            (excess_bucket, ticket_bucket, buckets1, buckets2)
        }

        // When the launch of a random launched coin ends, a user can use this method to get his
        // coins (for winning tickets) or get a partial refund (for losing tickets)
        // The method can handle a bucket of multiple tickets
        // Redeemed tickets are burned
        pub fn redeem_ticket(
            &mut self,

            // The tickets to redeem
            ticket_bucket: Bucket,
        ) -> (
            Bucket, // Base coins (losing tickets)
            Option<Bucket>, // Random launched coins (winning tickets)
            Option<Vec<Bucket>>, // Eventual buckets returned by the hooks for losers
            Option<Vec<Bucket>>, // Eventual buckets returned by the hooks for winners
        ) {
            // Use the ticket NonFungibleData to find the pool
            let ticket_id = &ticket_bucket.as_non_fungible().non_fungible_local_ids()[0];
            let ticket_data = ResourceManager::from_address(ticket_bucket.resource_address()).get_non_fungible_data::<TicketData>(ticket_id);
            let mut pool = self.pools.get_mut(&ticket_data.coin_resource_address).expect(COIN_NOT_FOUND);

            // Use the proxy badge to call the redeem_ticket method of the pool
            let (base_coin_bucket, coin_bucket, hook_argument_lose, hook_argument_win) = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.redeem_ticket(ticket_bucket)
            );

            // If there were losing tickets, get the hook list for the RedeemLosingTicket
            // operation
            let pool_enabled_hooks_lose = match hook_argument_lose {
                None => None,
                Some(ref hook_argument) => Some(pool.enabled_hooks.get_all_hooks(hook_argument.operation)),
            };

            // If there were winning tickets, get the hook list for the RedeemWinningTicket
            // operation
            let pool_enabled_hooks_win = match hook_argument_win {
                None => None,
                Some(ref hook_argument) => Some(pool.enabled_hooks.get_all_hooks(hook_argument.operation)),
            };

            // Drop the pool variable to avoid conflicting borrows
            drop(pool);

            // If there were losing tickets, invoke the enabled hooks for the RedeemLosingTicket
            // operation
            let lose_buckets = match hook_argument_lose {
                None => None,
                Some(hook_argument) => Some(
                    self.execute_hooks(
                        &pool_enabled_hooks_lose.unwrap(),
                        &hook_argument,
                    )
                ),
            };

            // If there were winning tickets, invoke the enabled hooks for the RedeemLosingTicket
            // operation
            let win_buckets = match hook_argument_win {
                None => None,
                Some(hook_argument) => Some(
                    self.execute_hooks(
                        &pool_enabled_hooks_win.unwrap(),
                        &hook_argument,
                    )
                ),
            };

            // Return all of the buckets to the user
            (base_coin_bucket, coin_bucket, lose_buckets, win_buckets)
        }

        // Users can add liquidity to a pool by using this method
        // The liquidity must include both base coins and coins in the same ratio as the ones
        // already in the pool. An excess of base coins is accepted
        pub fn add_liquidity(
            &mut self,

            // Base coins to add to the pool
            base_coin_bucket: Bucket,

            // Coins to add to the pool
            coin_bucket: Bucket,
        ) -> (
            Bucket, // Non fungibles representing the added liquidity
            Option<Bucket>, // Eventual excess coins to return
            Vec<Bucket>, // Eventual additional buckets returned by the hooks
        ) {
            // Find the pool
            let coin_address = coin_bucket.resource_address();
            let mut pool = self.pools.get_mut(&coin_address).expect(COIN_NOT_FOUND);

            // Use the proxy badge to call the add liquidity method of the pool
            let (lp_bucket, remainings_bucket, hook_argument, event, mode) =
                self.proxy_badge_vault.authorize_with_amount(
                    1,
                    || pool.component_address.add_liquidity(
                        base_coin_bucket,
                        coin_bucket,
                    )
                );

            // Get all of the info about the pool before dropping the pool variable
            let pool_enabled_hooks = pool.enabled_hooks.get_all_hooks(hook_argument.operation);
            let creator_id = pool.creator_id;
            drop(pool);

            // Emit the AddLiquidityEvent created by the pool
            self.emit_pool_event(event, 0);

            // It is possible that the pool was empty (Uninitialised mode); in this case adding
            // liquidity changes its state to Normal mode so the info in the creator NFT must be updated
            if mode.is_some() {
                self.update_mode_in_creator_nft(creator_id, mode.unwrap());
            }

            // Execute hooks for the AddLiquidity operation
            let buckets = self.execute_hooks(
                &pool_enabled_hooks,
                &hook_argument,
            );

            (lp_bucket, remainings_bucket, buckets)
        }

        // Use this method to get back the liquidity previously added to the pool
        // If the pool is in liquidation mode, only base coins will be returned, all of the coins
        // are kept by the pool
        // It is possible to redeem more than one liquidity token in a single operation
        pub fn remove_liquidity(
            &mut self,

            // LP tokens representing the added liquidity
            lp_bucket: Bucket,
        ) -> (
            Bucket, // Base coins
            Option<Bucket>, // Coins (if the pool is not in liquidation mode)
            Vec<Bucket>, // Eventual buckets returned by the hooks
        ) {
            // Use the LP token NonFungibleData to find the pool
            let lp_id = &lp_bucket.as_non_fungible().non_fungible_local_ids()[0];
            let lp_data = ResourceManager::from_address(lp_bucket.resource_address()).get_non_fungible_data::<LPData>(lp_id);
            let mut pool = self.pools.get_mut(&lp_data.coin_resource_address).expect(COIN_NOT_FOUND);

            // Use the proxy badge to invoke the remove_liquidity method of the pool
            let (base_coin_bucket, coin_bucket, hook_argument, event) = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.remove_liquidity(lp_bucket)
            );

            // Get the list of hooks for the RemoveLiquidity operation enabled on the pool and
            // drop the pool variable
            let pool_enabled_hooks = pool.enabled_hooks.get_all_hooks(hook_argument.operation);
            drop(pool);

            // Emit the RemoveLiquidityEvent created by the pool
            self.emit_pool_event(event, 0);

            // Execute all enabled hooks
            let buckets = self.execute_hooks(
                &pool_enabled_hooks,
                &hook_argument,
            );

            (base_coin_bucket, coin_bucket, buckets)
        }

        // A user can invoke this method to:
        // - buy coins using base coins
        // - sell coins for base coins
        // - swap a coin for another coin in a different pool
        pub fn swap(
            &mut self,

            // Coins the user wants to sell
            coin1_bucket: Bucket,

            // Address of the coins the user wants to receive
            coin2_address: ResourceAddress,

            // Id of the integrator whose interface allowed this operation
            mut integrator_id: u64,

        ) -> (
            Bucket, // Coin2
            Vec<Bucket>, // Eventual buckets returned by hooks invoked for the Sell operation
            Vec<Bucket> // Eventual buckets returned by hooks invoked for the Buy operation
        ) {
            // Verify that the swap makes sense
            assert!(
                coin1_bucket.amount() > Decimal::ZERO,
                "Coin1 bucket should not be empty",
            );
            let coin1_address = coin1_bucket.resource_address();
            assert!(
                coin1_address != coin2_address,
                "Can't swap a coin with itself",
            );

            // Verify that the integrator is valid and existing, or replace it with 0 (the component
            // owner)
            integrator_id = self.check_integrator_id(integrator_id);

            let (mut base_coin_bucket, buckets1) = match coin1_address == self.base_coin_address {

                // If coin1 is the base coin there's no sell operation
                true => (coin1_bucket, vec![]),

                false => self.sell(coin1_bucket, integrator_id),
            };
 
            // Whatever coin1 was, now we have a bucket of base coins, use this to pay the fees to
            // the integrator or the component owner
            self.deposit_fee(
                integrator_id,
                base_coin_bucket.take_advanced(
                    base_coin_bucket.amount() * self.buy_sell_fee_percentage / dec!(100),
                    WithdrawStrategy::Rounded(RoundingMode::ToZero),
                )
            );

            let coin2_bucket: Bucket;
            let mut buckets2: Vec<Bucket> = vec![];

            if coin2_address == self.base_coin_address {

                // If coin2 is the base coin there's no buy operation
                coin2_bucket = base_coin_bucket;
            } else {

                // If coin2 has to be bought, find its pool
                let mut pool = self.pools.get_mut(&coin2_address).expect("Coin2 not found");

                // Use the proxy badge to call the buy method of the pool of coin2
                let (bucket, hook_argument, event) = self.proxy_badge_vault.authorize_with_amount(
                    1,
                    || pool.component_address.buy(base_coin_bucket)
                );
                coin2_bucket = bucket;

                // Find the hooks for the Buy operation and drop the pool variable
                let pool_enabled_hooks = pool.enabled_hooks.get_all_hooks(hook_argument.operation);
                drop(pool);

                // Emit the BuyEvent for coin2
                self.emit_pool_event(event, integrator_id);

                // Execute hooks for the Buy operation
                buckets2 = self.execute_hooks(
                    &pool_enabled_hooks,
                    &hook_argument,
                );
            }

            (coin2_bucket, buckets1, buckets2)
        }

        // The component owner can call this method to create a pool for an already existing coin
        // The created pool will be empty (Uninitialised mode), it will need someone to
        // add_liquidity for it to be usable
        pub fn new_pool(
            &mut self,

            // Address of the coin whose pool has to be created
            coin_address: ResourceAddress,

            // Fees of the new pool
            buy_pool_fee_percentage: Decimal,
            sell_pool_fee_percentage: Decimal,
            flash_loan_pool_fee: Decimal,

        ) -> Bucket // Creator badge for the pool
        {
            // Make sure there isn't already a pool for this coin
            assert!(
                self.pools.get(&coin_address).is_none(),
                "There's already a pool for this coin",
            );

            // Make sure the fees are acceptable
            self.check_fees(
                buy_pool_fee_percentage,
                sell_pool_fee_percentage,
                flash_loan_pool_fee,
                false,
            );

            // Get metadata for the existing coin
            let resource_manager = ResourceManager::from_address(coin_address);
            let coin_symbol: String = resource_manager.get_metadata("symbol")
                .expect(UNEXPECTED_METADATA_TYPE)
                .expect("Coins without symbol are not allowed");
            let coin_name: String = resource_manager.get_metadata("name")
                .expect(UNEXPECTED_METADATA_TYPE)
                .expect("Coins without name are not allowed");
            let coin_icon_url: UncheckedUrl = resource_manager.get_metadata("icon_url")
                .expect(UNEXPECTED_METADATA_TYPE)
                .expect("Coins without icon are not allowed");

            // Do not check if name or symbol are forbidden so we can add well known coins.
            // Just add them to the lists if they aren't already there
            self.forbidden_symbols.insert(
                coin_symbol.to_uppercase().trim().to_string(),
                true,
            );
            self.forbidden_names.insert(
                coin_name.to_uppercase().trim().to_string(),
                true,
            );

            // Create the new pool
            let (pool, lp_resource_address) = Pool::new(
                self.owner_badge_address,
                self.proxy_badge_vault.resource_address(),
                self.hook_badge_vault.resource_address(),
                self.base_coin_address,
                coin_address,
                coin_name.clone(),
                coin_icon_url.clone(),
                buy_pool_fee_percentage,
                sell_pool_fee_percentage,
                flash_loan_pool_fee,
                self.next_creator_badge_rule(),
                self.dapp_definition,
            );

            // Add the new pool to the pools KVS
            self.pools.insert(
                coin_address,
                PoolStruct {
                    component_address: pool.into(),
                    enabled_hooks: HooksPerOperation::new(),
                    creator_id: self.next_creator_badge_id,
                }
            );

            // Mint a creator badge and return it to the user
            self.mint_creator_badge(
                coin_address,
                coin_name,
                coin_symbol,
                lp_resource_address,
                coin_icon_url,
                PoolMode::Uninitialised,
            )
        }

        // This method allows the owner to add an externally instantiated component as a pool.
        // It can also replace an existing pool with a new one.
        pub fn new_launched_pool(
            &mut self,
            coin_address: ResourceAddress,
            component_address: RadixPumpPoolInterfaceScryptoStub,
            lp_resource_address: ResourceAddress,
        ) -> Bucket // Creator badge for the pool
        {
            // Get the metadata for the coin
            let resource_manager = ResourceManager::from_address(coin_address);
            let coin_symbol: String = resource_manager.get_metadata("symbol")
                .expect(UNEXPECTED_METADATA_TYPE)
                .expect("Coins without symbol are not allowed");
            let coin_name: String = resource_manager.get_metadata("name")
                .expect(UNEXPECTED_METADATA_TYPE)
                .expect("Coins without name are not allowed");
            let coin_icon_url: UncheckedUrl = resource_manager.get_metadata("icon_url")
                .expect(UNEXPECTED_METADATA_TYPE)
                .expect("Coins without icon are not allowed");

            // Does a pool for this coin already exist?
            let mut opt_pool = self.pools.get_mut(&coin_address);
            match opt_pool {
                None => {
                    drop(opt_pool);

                    // If not add the new pool to the pools KVS
                    self.pools.insert(
                        coin_address,
                        PoolStruct {
                            component_address: component_address,
                            enabled_hooks: HooksPerOperation::new(),
                            creator_id: self.next_creator_badge_id,
                        }
                    );
                }
                Some(ref mut pool) => {

                    // If yes, replace the old one with the new one
                    pool.component_address = component_address;
                    pool.creator_id = self.next_creator_badge_id;

                    drop(opt_pool);

                    // Forbid new coins to have the same name or symbol
                    self.forbidden_symbols.insert(
                        coin_symbol.to_uppercase().trim().to_string(),
                        true,
                    );
                    self.forbidden_names.insert(
                        coin_name.to_uppercase().trim().to_string(),
                        true,
                    );
                },
            }

            // Mint a creator badge and return it to the user
            self.mint_creator_badge(
                coin_address,
                coin_name,
                coin_symbol,
                lp_resource_address,
                coin_icon_url,
                PoolMode::Uninitialised,
            )
        }

        // The creator badge containd useful informations about the coin and the pool; most of these
        // informations are fixed, only pool_mode is mutable
        // This private method is used to update pool_mode in the NFT every time che pool changes
        // its state
        fn update_mode_in_creator_nft(
            &self,

            // Numeric id of the creator badge NFT
            creator_id: u64,

            // New pool mode to set
            mode: PoolMode,
        ) {
            // Get the NonFungibleLocalId for creator_id
            let id = NonFungibleLocalId::integer(creator_id.into());

            // If the coin creator badge has not been burned
            if self.creator_badge_resource_manager.non_fungible_exists(&id) {

                // Update the pool_mode field in it
                self.creator_badge_resource_manager.update_non_fungible_data(
                    &id,
                    "pool_mode",
                    mode,
                );
            }
        }

        // This private method is used to check that an integrator_id corresponds to an integrator
        // badge that has not been disabled
        // If the chack fails, 0 is returned (it represents the componet owner himself)
        fn check_integrator_id(
            &mut self,

            // The integrator_id to check
            mut integrator_id: u64,

        ) -> u64 // The verified integrator_id
        {
            // If it's already 0, no check is needed
            if integrator_id > 0 {
                let id = NonFungibleLocalId::integer(integrator_id);

                // Check that the integrator badge exists
                if !self.integrator_badge_resource_manager.non_fungible_exists(&id) {
                    integrator_id = 0;
                }

                if integrator_id > 0 {

                    // Get the NonFungibleData of the integrator badge
                    let integrator_data =
                        self.integrator_badge_resource_manager.get_non_fungible_data::<IntegratorData>(&id);
 
                    // Check that it is active
                    if !integrator_data.active {
                        integrator_id = 0;
                    }
                }
            }

            integrator_id
        }

        // This private method is used to deposit fees owed to the component owner or to an
        // integrator
        fn deposit_fee(
            &mut self,

            // Numeric id of the integrator badge (or zero for the component owner)
            integrator_id: u64,

            // Thee fee to deposit
            fee_bucket: Bucket,
        ) {
            // Create the fee vault if it doesn't exist
            if self.fee_vaults.get(&integrator_id).is_none() {
                self.fee_vaults.insert(integrator_id, Vault::new(self.base_coin_address));
            }

            // Deposit the fee bucket in the vault
            self.fee_vaults.get_mut(&integrator_id).unwrap().put(fee_bucket);
        }

        // This private method is used to mint a new integrator badge
        pub fn new_integrator(
            &mut self,

            // The name to assign to the integrator; this has no real use, just a reminder for the
            // component owner
            name: String,

        ) -> Bucket // The minted integrator badge
        {
            // Mint the integrator badge
            let integrator_badge = self.integrator_badge_resource_manager.mint_non_fungible(
                &NonFungibleLocalId::integer(self.next_integrator_badge_id.into()),
                IntegratorData {
                    name: name,
                    creation_date: Clock::current_time_rounded_to_seconds(),
                    active: true,
                }
            );

            // Prepare for the next one
            self.next_integrator_badge_id += 1;

            integrator_badge
        }

        // This component sets the same dapp_definition metadata on all of the components and resources
        // Unfortunately there'a a limit an the number of objects a dApp definiton account can
        // handle, so this method update the dapp_definition value that will be set on the next created objects
        // without touching the existing ones
        // Only the component owner can invoke this method
        pub fn update_dapp_definition(
            &mut self,
            dapp_definition: ComponentAddress,
        ) {
            self.dapp_definition = dapp_definition;
        }

        // Returns a proxy badge and a hook badge; it can be useful to set up a Timer component or
        // to replace the RadixPump component with a new one
        // This method can only be called by the component owner
        pub fn get_badges(&self) -> (
            Bucket, // Proxy badge
            Bucket, // Hook badge
        ) {
            (
                ResourceManager::from_address(
                    self.proxy_badge_vault.resource_address()
                )
                .mint(1),
                ResourceManager::from_address(
                    self.hook_badge_vault.resource_address()
                )
                .mint(1)
            )
        }

        fn sell(
            &mut self,
            coin_bucket: Bucket,
            integrator_id: u64,
        ) -> (
            Bucket, // Base coins
            Vec<Bucket>, // Eventual buckets returned by hooks
        ) {
            // Find the pool to sell coins
            let coin_address = coin_bucket.resource_address();
            let mut pool = self.pools.get_mut(&coin_address).expect("Coin not found");

            // Use the proxy badge to call the sell method of the pool of coin1
            let (bucket, hook_argument, event) = self.proxy_badge_vault.authorize_with_amount(
                1,
                || pool.component_address.sell(coin_bucket)
            );

            // Find the hooks for the Sell operation and drop the pool variable
            let pool_enabled_hooks = pool.enabled_hooks.get_all_hooks(hook_argument.operation);
            drop(pool);

            // Emit the SellEvent
            self.emit_pool_event(event, integrator_id);

            // Execute hooks for the Sell operation
            let buckets = self.execute_hooks(
                &pool_enabled_hooks,
                &hook_argument,
            );

            (bucket, buckets)
        }
    }
}
